---
alwaysApply: true
appliesTo:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.mts"
  - "**/*.cts"
---

# TypeScript 编码规范

## 规范说明

本规范基于深入的 TypeScript 语言特性分析和大规模项目实践，定义了 TypeScript 特有类型系统的编码标准。规范专注于 Enum、Interface、联合类型等 TypeScript 专有特性的最佳实践，确保类型安全、代码可读性和维护性。

> 💡 **注意**: 通用的 JavaScript 标识符命名（变量、函数、类等）请参考 `code-naming.mdc`

### 🎯 核心依据

- **TypeScript 官方文档** - TypeScript Handbook 中的类型系统和最佳实践指导
- **主流开源项目实践** - React、Vue、Angular、VS Code、TypeORM 等顶级 TypeScript 项目的类型定义模式
- **类型安全原则** - 强类型系统的安全性、可维护性和开发效率优化
- **现代 TypeScript 特性** - 基于 TypeScript 4.0+ 的现代语法和编译器优化
- **企业级项目经验** - 大型 TypeScript 项目中的类型设计模式和团队协作实践

## Enum 命名规范

### 🏆 核心原则

1. **语义化优先** - 名称应清晰表达用途和上下文
2. **一致性** - 团队内保持统一的命名风格
3. **可读性** - 让其他开发者一目了然

### 📛 基础命名规则

#### 1. 枚举类型命名

- **使用 PascalCase**
- **使用单数形式**
- **语义完整性**

```typescript
// ✅ 正确
enum UserRole { ... }
enum OrderStatus { ... }
enum HttpStatusCode { ... }

// ❌ 避免
enum UserRoles { ... }        // 错误：复数形式
enum user_role { ... }        // 错误：snake_case
enum httpStatusCode { ... }   // 错误：小写开头
```

#### 2. 枚举成员命名

**使用 PascalCase**（现代主流风格）

```typescript
// ✅ 正确：PascalCase 命名
enum Color {
  Red = "RED",
  Blue = "BLUE",
  Green = "GREEN",
}

enum UserStatus {
  Active = "active",
  Inactive = "inactive",
  Suspended = "suspended",
}
```

### 🎯 特定场景命名指南

#### 1. 状态枚举

使用 `[实体]Status` 格式：

```typescript
// ✅ 订单状态
enum OrderStatus {
  Pending = "pending", // 待处理
  Processing = "processing", // 处理中
  Shipped = "shipped", // 已发货
  Delivered = "delivered", // 已送达
  Cancelled = "cancelled", // 已取消
}
```

#### 2. 角色/权限枚举

使用 `[系统]Role` 格式：

```typescript
// ✅ 系统角色
enum SystemRole {
  Administrator = "admin", // 管理员
  Editor = "editor", // 编辑
  Contributor = "contributor", // 贡献者
  Viewer = "viewer", // 查看者
}
```

#### 3. 错误代码枚举

使用分类前缀 + `ErrorCode` 格式：

```typescript
// ✅ API错误代码
enum ApiErrorCode {
  // 认证错误 (1000系列)
  AuthenticationFailed = 1001,
  InvalidToken = 1002,
  TokenExpired = 1003,

  // 资源错误 (2000系列)
  ResourceNotFound = 2001,
  PermissionDenied = 2002,

  // 验证错误 (3000系列)
  ValidationFailed = 3001,
  InvalidInput = 3002,
}
```

#### 4. 配置选项枚举

使用功能 + 选项格式：

```typescript
// ✅ 日志级别
enum LogLevel {
  Debug = "debug", // 调试
  Info = "info", // 信息
  Warn = "warn", // 警告
  Error = "error", // 错误
  Critical = "critical", // 严重
}
```

### 🎯 命名决策流程

```mermaid
graph TD
    A[需要定义枚举？] --> B{枚举用途是什么？}
    B -->|状态管理| C["[实体]Status"]
    B -->|角色/权限| D["[系统]Role"]
    B -->|错误代码| E["[分类]ErrorCode"]
    B -->|配置选项| F["[功能] + 选项"]
    C --> G[使用 PascalCase]
    D --> G
    E --> G
    F --> G
    G --> H{是字符串枚举？}
    H -->|是| I[显式赋值字符串值]
    H -->|否| J[考虑是否使用数字值]

    style G fill:#e8f5e8
    style I fill:#e3f2fd
    style J fill:#fff3e0
```

### ❌ 避免的常见错误

```typescript
// ❌ 过于泛化的名称
enum Status { ... }  // 缺乏上下文，应为 PaymentStatus
enum Type { ... }    // 太泛化，应为 FileType

// ❌ 不必要的缩写
enum CustType { ... }  // 不清晰，应为 CustomerType
enum ProdStat { ... }  // 模糊，应为 ProductStatus

// ❌ 不一致的命名风格
enum Color {
  red,     // 小写
  BLUE,    // 大写
  Green,   // 首字母大写
}

// ❌ 字符串枚举缺少显式赋值
enum Direction {
  North,   // 错误：字符串枚举需要初始化
  South,   // 错误：应为 South = "SOUTH"
}
```

### 💡 高级技巧

#### 1. 常量枚举优化性能

```typescript
// 编译时内联，提升性能
const enum Size {
  Small = "SM",
  Medium = "MD",
  Large = "LG",
}
```

#### 2. 联合类型替代方案

```typescript
// 零运行时开销的轻量级枚举
const UserRole = {
  Admin: "ADMIN",
  Editor: "EDITOR",
} as const;

type UserRole = (typeof UserRole)[keyof typeof UserRole];
```

> **黄金法则**：枚举名称应该让开发者无需查看实现就能理解其目的和用法

## Interface 命名规范

### 接口名规则

1. **PascalCase 命名**
   - ✅ `UserProfile` - 首字母大写，无分隔符
   - ❌ `userProfile` - 小写开头

2. **语义化的名词**
   - ✅ `DataParser` - 表示解析器的类型
   - ✅ `PaymentStrategy` - 表示策略模式中的策略类型

3. **避免冗余前缀**
   - ✅ `User` - 简洁明确
   - ❌ `IUser` - 冗余的 I 前缀

4. **精确描述范围**
   - ✅ `ApiResponse<T>` - 明确用于 API 响应
   - ✅ `AppState` - 表示全局状态

### 接口属性规则

1. **camelCase 命名**
   - ✅ `firstName`, `createdAt` - 小驼峰式
   - ❌ `FirstName`, `created_at` - 大写开头或下划线

2. **明确语义，避免缩写**
   - ✅ `maxRetryAttempts` - 清晰完整
   - ✅ `timeoutMs` - 带单位说明
   - ❌ `mxRtAtmpt` - 模糊缩写

3. **布尔值使用语义前缀**
   - ✅ `isEnabled`, `hasPermission` - 明确布尔意图
   - ❌ `enable`, `permission` - 缺少语义前缀

4. **集合类型使用复数形式**

集合类型属性应使用复数形式，避免在变量名中重复类型信息：

#### 🎯 核心原则：类型信息不重复

```typescript
// ✅ 推荐：复数形式已经表达了集合含义
interface ProductStore {
  items: Product[]; // 而不是 itemList
  users: User[]; // 而不是 userArray
  discounts: Map<string, number>; // 而不是 discountMap
  categories: Set<string>; // 而不是 categorySet
}

// ❌ 避免：冗余后缀
interface ProductStore {
  itemList: Product[]; // 冗余：类型已说明是数组
  userArray: User[]; // 冗余：Array 后缀多余
  discountMap: Map<string, number>; // 冗余：Map 后缀多余
}
```

#### 💡 复数形式的优势

1. **避免信息冗余** - `Product[]` 类型已明确表示数组结构
2. **更自然的语义** - `items` 比 `itemList` 读起来更自然
3. **灵活性更好** - 改变数据结构时变量名仍然合适
4. **遵循业界最佳实践** - 主流代码库的常见模式

### 标准格式

```typescript
// ✅ 最佳实践：明确描述对象类型
interface UserProfile {
  id: string;
  firstName: string;
  isActive: boolean;
  permissions: string[];
}

interface HttpClientConfig {
  timeoutMs: number;
  maxRetryAttempts: number;
  isRetryEnabled: boolean;
}

// ❌ 避免：不规范的命名
interface IUserProfile {
  // 错误：冗余 I 前缀
  FirstName: string; // 错误：大写开头
  created_at: Date; // 错误：snake_case
  enable: boolean; // 错误：缺少语义前缀
  itemList: Product[]; // 错误：冗余 List 后缀
}
```

## 联合类型命名规范

### 🏆 核心原则

1. **语义化命名** - 类型名应清晰表达联合类型的用途
2. **可辨识性** - 优先使用可辨识联合模式
3. **类型安全** - 确保穷尽性检查和类型收窄

### 📛 基础命名规则

#### 1. 联合类型命名

- **使用 PascalCase**
- **语义完整性**
- **避免过度泛化**

```typescript
// ✅ 正确：语义清晰的联合类型
type PaymentMethod = "creditCard" | "paypal" | "bankTransfer";
type UserRole = "admin" | "editor" | "viewer";
type LogLevel = "debug" | "info" | "warn" | "error";

// ❌ 避免：模糊的命名
type Options = string | number;
type Types = "A" | "B";
type Data = boolean | null;
```

#### 2. 可辨识联合模式

**使用公共字段作为判别式**

```typescript
// ✅ 推荐：标准可辨识联合
type ApiResponse<T> =
  | { status: "success"; data: T }
  | { status: "error"; code: number; message: string }
  | { status: "loading" };

// ✅ 推荐判别字段名：kind, type, status
type NetworkEvent = { kind: "connected"; ip: string } | { kind: "disconnected"; reason: string };
```

#### 3. 字面量联合规范

```typescript
// ✅ 推荐：使用常量避免魔法字符串
const THEMES = ["light", "dark", "high-contrast"] as const;
type Theme = (typeof THEMES)[number];

// ✅ 推荐：描述性字面值
type Environment = "development" | "staging" | "production";

// ❌ 避免：模糊的字面值
type Mode = "a" | "b" | "c";
```

### 📝 联合类型格式化规范

#### 🎯 前置 `|` 格式（推荐）

**对于多行联合类型，优先使用前置 `|` 格式**：

```typescript
// ✅ 推荐：多行联合类型使用前置 |
type ApiResponse<T> =
  | { status: "success"; data: T }
  | { status: "error"; code: number; message: string }
  | { status: "loading" };

type UserAction =
  | { type: "login"; username: string }
  | { type: "logout" }
  | { type: "update"; data: UserData }
  | { type: "refresh" };

// ✅ 单行联合类型可以省略前置 |
type Status = "pending" | "completed" | "failed";
type ID = string | number;
```

#### 🏆 前置 `|` 的优势

1. **视觉对齐清晰**

   ```typescript
   // ✅ 对齐清晰，一目了然
   type NetworkEvent =
     | { kind: "connected"; ip: string; timestamp: Date }
     | { kind: "disconnected"; reason: string; timestamp: Date }
     | { kind: "error"; error: Error; retryCount: number };
   ```

2. **易于维护修改**

   ```typescript
   // ✅ 添加/删除/注释类型很方便
   type UserRole =
     | { role: "admin"; permissions: AdminPermissions }
     | { role: "editor"; permissions: EditorPermissions }
     // | { role: "viewer"; permissions: ViewerPermissions } // 临时注释
     | { role: "guest"; permissions: {} };
   ```

3. **Git diff 更友好**

   ```diff
   type UserStatus =
     | { status: "active"; lastLogin: Date }
     | { status: "inactive"; reason: string }
   + | { status: "suspended"; until: Date }
     | { status: "pending"; verificationCode: string };
   ```

4. **符合工具默认格式**
   - Prettier 会自动格式化为前置 `|` 形式
   - 符合 TypeScript 官方推荐格式
   - 与主流开源项目保持一致

#### 📏 格式化决策规则

```typescript
// ✅ 简单联合（单行）
type Size = "small" | "medium" | "large";

// ✅ 复杂联合（多行 + 前置 |）
type FormState =
  | {
      stage: "editing";
      data: FormData;
      errors: ValidationErrors;
    }
  | {
      stage: "submitting";
      data: FormData;
    }
  | {
      stage: "success";
      result: SubmissionResult;
    };
```

### 类型安全实践

#### 1. 穷尽性检查

```typescript
// ✅ 使用 never 类型确保覆盖所有情况
function processStatus(status: ApiResponse<any>): void {
  switch (status.status) {
    case "success":
      // 处理成功
      break;
    case "error":
      // 处理错误
      break;
    case "loading":
      // 处理加载
      break;
    default:
      // 确保覆盖所有情况
      const _exhaustiveCheck: never = status;
      throw new Error(`Unhandled status: ${_exhaustiveCheck}`);
  }
}
```

#### 2. 类型保护

```typescript
// ✅ 创建类型保护函数
function isSuccess<T>(response: ApiResponse<T>): response is { status: "success"; data: T } {
  return response.status === "success";
}

// 使用
if (isSuccess(response)) {
  console.log(response.data); // 类型安全
}
```

### 标准格式

```typescript
// ✅ 最佳实践：完整的联合类型应用
export const USER_ROLES = ["admin", "editor", "viewer"] as const;
export type UserRole = (typeof USER_ROLES)[number];

export type UserPermissions =
  | { role: "admin"; permissions: { canDelete: boolean; canConfigure: boolean } }
  | { role: "editor"; permissions: { canEdit: boolean; canPublish: boolean } }
  | { role: "viewer"; permissions: { canView: boolean } };

// ✅ 泛型联合类型
export type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };

// ✅ 推荐：重构为可扩展结构
type Badge = {
  material: "bronze" | "silver" | "gold";
  level: 1 | 2 | 3;
};

// ❌ 避免：过大的联合类型
type BadgeLevel = "bronze1" | "bronze2" | "bronze3" | "silver1" | "silver2" | "silver3" | "gold1" | "gold2" | "gold3"; // 太多选项，考虑重构
```
